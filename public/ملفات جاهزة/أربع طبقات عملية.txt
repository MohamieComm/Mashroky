
التالي أربع طبقات عملية:

1. **نموذج البيانات (Prisma + Roles + مفاتيح متعددة)**
2. **Endpoints + صلاحيات (مالك حساب / فريق / مفاتيح متعددة)**
3. **لوحة React/Next.js لإدارة API Keys بنفس ثيم مشروع السفر**
4. **SDKs مكتملة (TS / Dart / Swift) تشمل Auth + API Keys**

---

### 1) نموذج البيانات: Prisma + Roles + مفاتيح متعددة

#### `prisma/schema.prisma`

```prisma
enum Role {
  OWNER
  ADMIN
  MEMBER
}

model User {
  id           String        @id @default(auto()) @map("_id") @db.ObjectId
  email        String        @unique
  passwordHash String
  createdAt    DateTime      @default(now())
  memberships  TeamMember[]
  apiKeys      ApiKey[]
  sessions     RefreshSession[]
}

model Team {
  id        String        @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  ownerId   String        @db.ObjectId
  owner     User          @relation(fields: [ownerId], references: [id])
  members   TeamMember[]
  apiKeys   ApiKey[]
  createdAt DateTime      @default(now())
}

model TeamMember {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  teamId    String   @db.ObjectId
  role      Role
  user      User     @relation(fields: [userId], references: [id])
  team      Team     @relation(fields: [teamId], references: [id])
  createdAt DateTime @default(now())
}

model ApiKey {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  key       String   @unique
  label     String
  teamId    String?  @db.ObjectId
  userId    String?  @db.ObjectId
  team      Team?    @relation(fields: [teamId], references: [id])
  user      User?    @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  revoked   Boolean  @default(false)
}

model RefreshSession {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  userId       String   @db.ObjectId
  user         User     @relation(fields: [userId], references: [id])
  refreshToken String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())
}
```

> الآن عندك:  
> **User ↔ Team ↔ TeamMember (Role)** + **ApiKey متعددة لكل فريق/مستخدم**.

---

### 2) Endpoints + صلاحيات (مالك / فريق / مفاتيح متعددة)

#### 2.1 Repository لمفاتيح الـ API

```ts
// src/repositories/apiKeyRepo.ts
import { prisma } from "../lib/prisma.js";
import { generateApiKey } from "../services/apiKeyService.js";

export const listTeamApiKeys = (teamId: string) =>
  prisma.apiKey.findMany({ where: { teamId, revoked: false } });

export const createTeamApiKey = async (teamId: string, label: string) => {
  const key = generateApiKey();
  return prisma.apiKey.create({
    data: { key, label, teamId }
  });
};

export const revokeApiKey = (id: string, teamId: string) =>
  prisma.apiKey.updateMany({
    where: { id, teamId },
    data: { revoked: true }
  });

export const findByKey = (key: string) =>
  prisma.apiKey.findFirst({ where: { key, revoked: false } });
```

#### 2.2 Middleware للتحقق من الدور (Role-based)

```ts
// src/middleware/requireRole.ts
import { Request, Response, NextFunction } from "express";

export const requireRole =
  (roles: ("OWNER" | "ADMIN" | "MEMBER")[]) =>
  (req: Request, res: Response, next: NextFunction) => {
    const member = (req as any).member; // محمّل مسبقًا من middleware آخر
    if (!member || !roles.includes(member.role)) {
      return res.status(403).json({ message: "صلاحيات غير كافية" });
    }
    next();
  };
```

> تحتاج قبلها Middleware يحمّل `member` من `TeamMember` بناءً على `userId` و `teamId` (من الـ JWT أو من الـ query).

#### 2.3 Routes لإدارة مفاتيح الفريق

```ts
// src/routes/teamApiKeyRoutes.ts
import { Router, Request, Response } from "express";
import { listTeamApiKeys, createTeamApiKey, revokeApiKey } from "../repositories/apiKeyRepo.js";
import { requireRole } from "../middleware/requireRole.js";

const router = Router();

// GET /teams/:teamId/api-keys
router.get(
  "/teams/:teamId/api-keys",
  requireRole(["OWNER", "ADMIN"]),
  async (req: Request, res: Response) => {
    const { teamId } = req.params;
    const keys = await listTeamApiKeys(teamId);
    res.json(keys);
  }
);

// POST /teams/:teamId/api-keys
router.post(
  "/teams/:teamId/api-keys",
  requireRole(["OWNER", "ADMIN"]),
  async (req: Request, res: Response) => {
    const { teamId } = req.params;
    const { label } = req.body;
    const key = await createTeamApiKey(teamId, label || "Default key");
    res.status(201).json(key);
  }
);

// DELETE /teams/:teamId/api-keys/:id
router.delete(
  "/teams/:teamId/api-keys/:id",
  requireRole(["OWNER", "ADMIN"]),
  async (req: Request, res: Response) => {
    const { teamId, id } = req.params;
    await revokeApiKey(id, teamId);
    res.json({ message: "تم إلغاء المفتاح" });
  }
);

export default router;
```

---

### 3) ربط اللوحة فعليًا مع React / Next.js (ثيم مشروع السفر – أزرق داكن)

نفترض Next.js 14 (App Router) + Tailwind (أو CSS بسيط).

#### 3.1 صفحة إدارة مفاتيح API

```tsx
// app/dashboard/api-keys/page.tsx
"use client";

import { useEffect, useState } from "react";

type ApiKey = {
  id: string;
  label: string;
  key: string;
  createdAt: string;
};

export default function ApiKeysPage() {
  const [keys, setKeys] = useState<ApiKey[]>([]);
  const [label, setLabel] = useState("");
  const teamId = "TEAM_ID_FROM_CONTEXT"; // من session / router / context
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE!;
  const accessToken = ""; // من auth context

  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${accessToken}`
  };

  const loadKeys = async () => {
    const res = await fetch(`${baseUrl}/teams/${teamId}/api-keys`, { headers });
    const data = await res.json();
    setKeys(data);
  };

  const createKey = async () => {
    const res = await fetch(`${baseUrl}/teams/${teamId}/api-keys`, {
      method: "POST",
      headers,
      body: JSON.stringify({ label })
    });
    const data = await res.json();
    setKeys((prev) => [...prev, data]);
    setLabel("");
  };

  const revokeKey = async (id: string) => {
    await fetch(`${baseUrl}/teams/${teamId}/api-keys/${id}`, {
      method: "DELETE",
      headers
    });
    setKeys((prev) => prev.filter((k) => k.id !== id));
  };

  useEffect(() => {
    loadKeys();
  }, []);

  return (
    <div className="min-h-screen bg-slate-950 text-slate-100">
      <div className="max-w-4xl mx-auto py-10 px-6">
        <h1 className="text-2xl font-semibold mb-2">مفاتيح API</h1>
        <p className="text-slate-400 mb-6">
          إدارة مفاتيح الوصول لتطبيقات السفر داخل فريقك.
        </p>

        <div className="bg-slate-900 border border-slate-800 rounded-2xl p-5 mb-6">
          <label className="block text-sm text-slate-400 mb-2">اسم المفتاح</label>
          <input
            value={label}
            onChange={(e) => setLabel(e.target.value)}
            className="w-full rounded-lg bg-slate-950 border border-slate-700 px-3 py-2 text-sm mb-3"
            placeholder="مثال: تطبيق الموبايل"
          />
          <button
            onClick={createKey}
            className="px-4 py-2 rounded-full bg-sky-600 hover:bg-sky-500 text-sm"
          >
            إنشاء مفتاح جديد
          </button>
        </div>

        <div className="bg-slate-900 border border-slate-800 rounded-2xl p-5">
          {keys.map((k) => (
            <div
              key={k.id}
              className="flex items-center justify-between border-b border-slate-800 last:border-none py-3"
            >
              <div>
                <div className="text-sm font-medium">{k.label}</div>
                <div className="text-xs text-slate-400 mt-1 break-all">
                  {k.key}
                </div>
              </div>
              <button
                onClick={() => revokeKey(k.id)}
                className="text-xs text-red-400 hover:text-red-300"
              >
                إلغاء
              </button>
            </div>
          ))}
          {keys.length === 0 && (
            <div className="text-sm text-slate-500">لا توجد مفاتيح بعد.</div>
          )}
        </div>
      </div>
    </div>
  );
}
```

> الثيم: أزرق داكن/Slate، قريب جدًا من لوحة مشروع السفر اللي أرسلتها.

---

### 4) SDKs مكتملة (TS / Dart / Swift) تشمل Auth + API Keys

#### 4.1 TypeScript SDK

```ts
// sdk/ts/travelClient.ts
export interface TravelClientOptions {
  baseUrl: string;
  apiKey?: string;
}

export class TravelClient {
  private accessToken?: string;
  private refreshToken?: string;

  constructor(private opts: TravelClientOptions) {}

  setTokens(accessToken: string, refreshToken?: string) {
    this.accessToken = accessToken;
    if (refreshToken) this.refreshToken = refreshToken;
  }

  private headers(extra?: Record<string, string>) {
    return {
      "Content-Type": "application/json",
      ...(this.opts.apiKey && { "X-API-Key": this.opts.apiKey }),
      ...(this.accessToken && { Authorization: `Bearer ${this.accessToken}` }),
      ...extra
    };
  }

  // Auth
  async login(email: string, password: string) {
    const res = await fetch(`${this.opts.baseUrl}/auth/login`, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify({ email, password })
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    this.setTokens(data.accessToken, data.refreshToken);
    this.opts.apiKey = data.apiKey;
    return data;
  }

  // Unified search
  async unifiedSearch(params: { origin: string; destination: string; date: string }) {
    const url = new URL("/api/travel/search", this.opts.baseUrl);
    Object.entries(params).forEach(([k, v]) => url.searchParams.set(k, v));
    const res = await fetch(url, { headers: this.headers() });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  // Team API keys
  async listTeamApiKeys(teamId: string) {
    const res = await fetch(`${this.opts.baseUrl}/teams/${teamId}/api-keys`, {
      headers: this.headers()
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  async createTeamApiKey(teamId: string, label: string) {
    const res = await fetch(`${this.opts.baseUrl}/teams/${teamId}/api-keys`, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify({ label })
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  async revokeTeamApiKey(teamId: string, id: string) {
    const res = await fetch(`${this.opts.baseUrl}/teams/${teamId}/api-keys/${id}`, {
      method: "DELETE",
      headers: this.headers()
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }
}
```

#### 4.2 Dart SDK (مختصر بنفس المنطق)

```dart
class TravelClient {
  final String baseUrl;
  String? apiKey;
  String? accessToken;
  String? refreshToken;

  TravelClient({required this.baseUrl, this.apiKey});

  Map<String, String> _headers() => {
        'Content-Type': 'application/json',
        if (apiKey != null) 'X-API-Key': apiKey!,
        if (accessToken != null) 'Authorization': 'Bearer $accessToken',
      };

  Future<Map<String, dynamic>> login(String email, String password) async {
    final res = await http.post(
      Uri.parse('$baseUrl/auth/login'),
      headers: _headers(),
      body: jsonEncode({'email': email, 'password': password}),
    );
    if (res.statusCode != 200) throw Exception('HTTP ${res.statusCode}');
    final data = jsonDecode(res.body);
    accessToken = data['accessToken'];
    refreshToken = data['refreshToken'];
    apiKey = data['apiKey'];
    return data;
  }

  Future<dynamic> unifiedSearch(String origin, String destination, String date) async {
    final uri = Uri.parse('$baseUrl/api/travel/search').replace(
      queryParameters: {'origin': origin, 'destination': destination, 'date': date},
    );
    final res = await http.get(uri, headers: _headers());
    if (res.statusCode != 200) throw Exception('HTTP ${res.statusCode}');
    return jsonDecode(res.body);
  }
}
```

#### 4.3 Swift SDK (مختصر)

```swift
struct TravelClient {
    let baseUrl: URL
    var apiKey: String?
    var accessToken: String?

    private func headers() -> [String: String] {
        var h: [String: String] = ["Content-Type": "application/json"]
        if let apiKey { h["X-API-Key"] = apiKey }
        if let accessToken { h["Authorization"] = "Bearer \(accessToken)" }
        return h
    }

    func unifiedSearch(origin: String, destination: String, date: String,
                       completion: @escaping (Result<Data, Error>) -> Void) {
        var components = URLComponents(url: baseUrl.appendingPathComponent("/api/travel/search"), resolvingAgainstBaseURL: false)!
        components.queryItems = [
            .init(name: "origin", value: origin),
            .init(name: "destination", value: destination),
            .init(name: "date", value: date)
        ]
        var request = URLRequest(url: components.url!)
        headers().forEach { request.addValue($0.value, forHTTPHeaderField: $0.key) }

        URLSession.shared.dataTask(with: request) { data, _, error in
            if let error = error { completion(.failure(error)); return }
            completion(.success(data ?? Data()))
        }.resume()
    }
}
```

---